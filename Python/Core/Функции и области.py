# Если функция не использует инструкцию return, возвращается None

# Области видимости =================================================================================
# ЛОКАЛЬНЫЕ ИМЕНА ОПРЕДЕЛЯЮТСЯ СТАТИЧЕСКИ, Т.Е. ВО ВРЕМЯ КОМПИЛЯЦИИ
# ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ СОХРАНЯЮТСЯ В МОМЕНТ ОПРЕДЕЛЕНИЯ ФУНКЦИИ, ЧТО ПОЗВОЛЯЕТ ИХ СОХРАНЯТЬ
# Имена, определяемые в инструкции def, видны только внутри def
# Если присваивание переменной выполняется внутри инструкции def, переменная является ЛОКАЛЬНОЙ для этой функции
# Если присваивание производится в пределах объемлющей инструкции def, переменная является НЕЛОКАЛЬНОЙ для этой функции
# Если присваивание производится за пределами всех инструкций def, она является ГЛОБАЛЬНОЙ для всего файла
# Local - локальная
# Enclosing - объемлющая
# Global - глобальная (для модуля)
# Built-in - встроенная
global x1, x2, x3, x4 # Объявление переменной, находящейся в модульной области видимости
# ЕСЛИ ЛЯМБДА-ВЫРАЖЕНИЕ ИЛИ ИНСТРУКЦИЯ DEF ВЛОЖЕНЫ В ЦИКЛ ВНУТРИ ДРУГОЙ ФУНКЦИИ И ВЛОЖЕННАЯ ФУНКЦИЯ ССЫЛАЕТСЯ НА ПЕРЕМЕННУЮ ИЗ
# ОБЪЕМЛЮЩЕЙ ОБЛАСТИ ВИДИМОСТИ, КОТОРАЯ ИЗМЕНЯЕТСЯ В ЦИКЛЕ, ВСЕ ФУНКЦИИ СОЗДАННЫЕ В ЭТОМ ЦИКЛЕ БУДУТ ИМЕТЬ ОДНО И ТО ЖЕ ЗНАЧЕНИЕ
# — КОТОРАЯ ИМЕЛА ПЕРЕМЕННАЯ НА ПОСЛЕДНЕЙ ИТЕРАЦИИ
nonlocal x1 # Объявление переменной вложенной функции ТОЛЬКО PYTHON 3.0

# Аргументы =========================================================================================
# Аргументы передаются через автоматическое присваивание объектов локальным переменным

# Возврат нескольких значений с помощью кортежей
def func():
	return x, y
x1, y1 = func()

def func(*args, **kwargs): # Объявление функции с переменным числом аргументов. Позиционные записываются в кортеж, имен. - в словарь
def func(*, **kwargs): # Аргументы должны передаваться только по именам ТОЛЬКО PYTHON 3.0
func(*args, **kwargs) # Вызов функции, которой передаются параметры из массива args и словаря kwargs

# Порядок следования аргументов:
def func(args, kwargs=values, *args, **kwargs):

f = lambda x, y, z: x + y + z # Создание лямбда-функции


# Генераторы (функции-генераторы возвращают объект-итератор, а не выполняются):
def func():
	for range(10):
		yield x # Итеративная поставка значений. При следующей итерации (при вызыве функции obj.send(h)) на место
		# выражения yield x становится h
# Сопрограммы
def func():
	for x in ...:
		x = (yield y)
s = func()
s.next()
s.send(5)
gen.close() # Закрытие генератора
		
# Аттрибуты пользовательских функций:
f.__doc__ # Строка документирования
f.__name__ # Имя функции
f.__dict__ # Словарь с аттрибутами функции
f.__code__ # Скомпилированный байт-код функции
f.__defaults__ # Кортеж с аргументами по умолчанию
f.__globals__ # Словарь, определяющий глобальное пространство имен
f.__closure__ # Кортеж, содержащий данные, связанные с вложенными областями видимости

# Декораторы ==========================================================================================
# Определение декоратора
def check(func):
	def callf(*args, **kwargs):
		...
		return func(*args, **kwargs)
	# Для правильной работы строк документирования необходимо копировать эти атрибуты
	callf.__name__ = func.__name__
	callf.__doc__ = func.__doc__
	return callf
# Использование декоратора
@check
def myFunc():
	...