# Алгоритмы и управление потоком выполнения

## Циклы

### Производительность цикла

Из четырех типов циклов только цикл `for-in` оказывается существенно медленнее остальных. Одно и то же количество итераций `for-in` может выполняться в семь раз медленнее, чем в циклах других типов. По этой причине рекомендуется избегать использования циклов for-in, если только нет необходимости выполнить обход заранее неизвестного количества объектов.

За исключением цикла `for-in`, все остальные типы циклов имеют одинаковую производительность.

На производительность цикла влияют два условия:

* Объем работы, выполняемый в одной итерации.
* Количество итераций.

### Уменьшение объема работы, выполняемой в одной итерации

Первым шагом к уменьшению объема работы, выполняемой в цикле, является уменьшение числа операций поиска членов объектов и элементов массивов, так как доступ к локальным переменным выполняется гораздо быстрее, чем к элементам массивов и объектов.

    for (var i = 0, length = arr.length; i < length; i++) {
        // ...
    }

Если порядок итераций не имеет значения, можно уменьшить число операций поиска свойства и сделать обход в обратном направлении:

    for (var i = items.length; i--; ) {
        // ...
    }

### Уменьшение количества итераций

Шаблон "Устройство Даффа" позволяет уменьшить общее количество итераций. Он эффективен при количестве итераций более 1000. При цикле в 500 000 итераций прирост производительности составляет почти 70%.

1 версия:

    var iterations = Math.floor(items.length / 8);
    startAt = items.length % 8,
    i = 0;
    
    do {
        switch (startAt) {
            case 0: process(items[i++]);
            case 7: process(items[i++]);
            case 6: process(items[i++]);
            case 5: process(items[i++]);
            case 4: process(items[i++]);
            case 3: process(items[i++]);
            case 2: process(items[i++]);
            case 1: process(items[i++]);
        }
        startAt - 0;
    } while (iterations--);

2 версия (более оптимизированная, без `switch`):

    var iterations = items.length % 8,
        i = items.length - 1;
    
    while (iterations) {
        process(items[i--]);
        iterations--;
    }
    
    iterations = Math.floor(items.length / 8);
    while (iterations) {
        process(items[i--]);
        process(items[i--]);
        process(items[i--]);
        process(items[i--]);
        process(items[i--]);
        process(items[i--]);
        process(items[i--]);
        process(items[i--]);
        iterations--;
    }

### Итерации на основе функций

В целом итерации на основе функций выполняются до восьми раз дольше обычных итераций, поэтому они не подходят в ситуациях, когда производительность имеет большое значение.

## Условные инструкции

### Сравнение if-else и switch

В большинстве случаев инструкция switch выполняется немного быстрее, чем инструкция if-else, но существенный прирост в скорости получается только при большом количестве условий.

Инструкцию if-else лучше использовать, когда имеются два дискретных значения или два диапазона значений, из которых приходится выбирать. Когда требуется проверить более двух дискретных значений, предпочтительнее использовать инструкцию switch.

### Оптимизация инструкций if-else

Простейшая оптимизация состоит в том, чтобы на первое место поставить проверки наиболее типичных условий. Чтобы обеспечить максимальную скорость выполнения, проверка условий в инструкциях if-else всегда должна выполняться в порядке от наиболее вероятных к наименее вероятным.

Можно также преобразовать последовательность проверок в несколько вложенных проверок, чтобы уменьшить среднее количество проверок.

### Поисковые таблицы

    var results = [result0, result1, result2, ...];
    return results[value];

Поисковые таблицы работают намного быстрее чем проверка условий if-else или switch.

## Рекурсия

### Ограниченность размера стека вызовов

При переполнении стека различные браузеры выдают сообщение (кроме Chrome).

В браузерах кроме Opera при переполнении стека возбуждается исключение.

### Шаблоны реализации рекурсии

Прямая рекурсия (когда функция вызывает сама себя):

    function recurse() {
        recurse();
    }
    
    recurse();

Второй, более сложный шаблон, основан на использовании двух функций:

    function first() {
        second();
    }
    
    function second() {
        first();
    }
    
    first();

> Пропущено: 104-108