!1 Функции

{-
// Именованная функция-выражение:
var add = function add(a, b) {
    return a + b;
}

// Неименованная функция-выражение, анонимная функция:
var add = function(a, b) {
    return a + b;
}

// Функция-объявление:
function sum(a, b) {
    return a + b;
}
-}

!2 Самоопределяемые функции

{-
function func() {
    console.log(1);
    func = function () {
        console.log(2);
    };
}
-}

!2 Немедленно вызываемые функции

{-
(function () {
    
}())
-}

!2 Немедленная инициализация объектов

{-
({
    name1: value1,
    name2: value2,
    init: function() {
        // Инициализация объекта.
    }
}).init(); // Также допустимо '}.init())';
-}

!2 Выделение ветвей, выполняющихся на этапе инициализации

Данный шаблон заключается в том, чтобы выделить объемныет операции (например, различные проверки) и выполнять их всего один раз, на этапе инициализации приложения.

!2 Свойства функций - шаблон мемоизации

Нестандартные свойства функций могут использоваться для кэширования результатов, возвращаемых функцией. Данный прием называется !!мемоицация (memorization).

{-
var myFunc = function () {
    var cachekey = JSON.stringify(Arra.prototype.slice.call(arguments)),
        result;
    if(!myFunc.cache(cachekey)) {
        result = {};
        // Продолжительные вычисления
        myFunc.cache[cachekey] = result;
    }
    return myFunc.cache[cachekey];
}
myFunc.cache = {};
-}

!2 Объекты с параметрами

Если необходимо передавать функции много параметров, лучше передавать их в виде свойств объекта.

!2 Каррирование

Процесс, в результате которого появляются функции, обладающие возможностью частичного применения, называется каррированием.

!3 Каррирование

Каррирование - это процесс преобразования, в данном случае - процесс преобразования функции.

{-
// Каррированная функция add().
// Принимает неполный список аргументов.
function add(x, y) {
    if (typeof y === 'undefined') { // Частичное применение.
        return function(y) {
            return x + y;
        };
    }
    // Полное применение.
    return x + y;
}
-}

Функция, выполняющая каррирование:

{-
function curry(fn) {
    var slice = Array.prototype.slice,
        stored_args = slice.call(arguments, 1);
    return function() {
        var new_args = slice.call(arguments),
            args = atored_args.concat(new_args);
        return fn.apply(null, args);
    };
}
-}

!3 Когда использовать каррирование

Если обнаруживается, что вы неоднократно вызываете одну и ту же функцию, передавая ей одни и те же параметры, эта функция наверняка является отличным кандидатом на каррирование.