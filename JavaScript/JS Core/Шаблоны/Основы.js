// Шлобальные переменные ======================================================

// Групповое присваивание переменных делает локальной только первую переменную, остальные становятся глобальными
var a = b = 0; // b — глобальная!
var a = (b = 0); // То же самое

// Глобальные переменные, созданные явно с помощью инструкции var, не могут быть удалены
var x = 5;
delete x;
alert(x); // 5
// Подразумеваемые переменные, созданные без помощи инструкции var, могут быть удалены
x = 0;
delete x;
alert(x); // error

// Получение доступа к глобальному объекту из функций, не являющихся методами
var global = (function(){
    return this;
})();

// Шаблон единственной инструкции var
function func() {
    var a = 1,
        b = 2,
        c = 3;
}

// Подъем: переменная считается объявленной в функции, если она объявлена в ее области видимости
var my = 'global';
function my() {
    alert(my); // Выведет "undefined", т.к. в данной функции переменная my объявлена, независимо от места
    var my = 'local';
}

// Циклы for ==================================================================

// При обычной итерации по массиву или коллекции (var i = 0; i < arr.length; i++) на каждой итерации производится обращение к коллекции или массиву, что замедляет работу. Поэтому при обходе в цикле лучше заранее определять длину коллекции
for(var i = 0, max = arr.length; i < max; i++) {
    //...
}

// Вместо i++ лучше использовать i += 1, так как i++ проявляет "излишнюю хитрость"
for(;; i += 1) {}
    
// Для наивысшей производительности можно также использовать обратный отсчет
// В качестве условного (второго) выражения используется декремент счетчика, в результате которого возвращается итоговое число, и если оно равно 0, цикл прекращается
for(var i = arr.length; i--; ) {}
    
// Циклы for-in (ПЕРЕЧИСЛЕНИЯ) ================================================

// Перечисления должны использоваться только с коллекциями и объектами (т.е. с не-массивами)

// Необходимо фильтровать свойства, чтобы случайно не использовать свойства прототипа
for(var key in obj) {
    if(obj.hasOwnProperty(key)) { }
}

// Можно также вызывать оригинальный метод, чтобы избежать случайное использование переопределенного метода
if(Object.prototype.hasOwnProperty.call(man, i)) {}
    
// Можно также использовать укороченную версию (не проходит проверку JSLint)
for(var key in obj) if(hasOwn.call(obj, key)) { }
    
// Операторы сравнения ========================================================

// Необходимо стараться всегда использовать операторы === и !==, чтобы избежать неявного приведения типов
if(x === y) { };

// parseInt() =================================================================

// Необходимо всегда указывать систему счисления методы parseInt()
parseInt(string, 10);

// Соглашения по оформлению программного кода =================================

// Всегда использовать фигурные скобки
if(x > y) {
    alert(x);
}

// Соглашения по именованию ===================================================

function myFunction() {} // Обычная функция
function MyFunction() {} // Функция-конструктор

var PI = 3.14; // Константы записываются прописными символами

obj._getClass = function() {} // Именование скрытых свойств

function Person(name) {
    this._name = name
    this._age = 0
}
Person.prototype.getName = function() {
    return this._name
}
Person.prototype.setName = function(name) {
    this._name = name;
}

// Комментарии ================================================================

/* Пропущено
55-62
*/