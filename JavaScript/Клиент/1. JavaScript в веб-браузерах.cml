!1 JavaScript в веб-браузерах

!2 Клиентский JavaScript

Все особенности и прикладные интерфейсы сосредоточены в объекте Window, сослаться на который можно с помощью идентификатора window.

!2 Встраивание JavaScript-кода в разметку HTML

{:
* Встроенные сценарии между парой тегов <script> и <}script>.
* Из внешнего файла, заданного атрибутом src тега <script>
* В обработчик события, заданный в качестве значения HTML-атрибута, такого как onclick или onmouseover.
* Как тело URL-адреса, использующего специальный спецификатор псевдопротокола JavaScript:.
:}

!3 Элемент <script>

В XHTML содержимое тега <script> обрабатывается наравне с содержимым любого другого тега. Если JavaScript-код содержит символы < или &, они интерпретируются как элементы XML-разметки. Поэтому в случае применения XHTML лучше помещать весь JavaScript-код внутрь секции CDATA:

{-
<script><![CDATA[
// Здесь располагается JavaScript-код.
]]<}script>
-}

!3 Сценарии во внешних файлах

При использовании атрибута src любой код, размещенный между тегами <script> и <}script> игнорируется.

!3 Тип сценария

По умолчанию атрибут type получает значение "text}JavaScript".

Раньше вместо type использовался атрибут language, но он считается устаревшим.

Когда браузер встречает элемент <script> с атрибутом type, значение которого он не может распознать, он пытается проанализировать элемент, но не отображает и не выполняет его содержимое. Это значит, что можно использовать тег <script> для встраивания в документ произвольных текстовых данных.

!3 Обработчики событий в HTML

Атрибуты обработчикой событий, включенных в разметку HTML, могут содержать одну или несколько JavaScript-инструкций, отделяемых друг от друга точками с запятой. Эти инструкции будут преобразованы интерпретатором в тело функции, которая станет значением соответствующего свойства обработчика события.

!3 JavaScript в URL

{-
javascript: code;
-}

Этот специальный тип протокола означает, что тело URL-адреса представляет собою произвольный JavaScript-код, который должен быть выполнен интерпретатором. Он интерпретируется как единственная строка, поэтому инструкции в ней должны быть отделены друг от друга точками с запятой, а для комментариев должны использоваться комбинации }* и *}. "Ресурсом", который определяется адресом, является значение, возвращаемое этим программным кодом, преобразованное в строку. Если программный код возвращает значение undefined, считается, что ресурс не имеет содержимого.

!3 Букмарклеты

Если закладка содержит URL-адрес javascript:, такая закладка играет роль мини-программы на языке JavaScript, которая называется букмарклетом. Код букмарклета выполняется как если бы он был кодом страницы.

!2 Выполнение JavaScript-программ

!3 Синхронные, асинхронные и отложенные сценарии

Когда интерпретатор встречает тег <script>, он должен (по умолчанию) выполнить сценарий, прежде чем продолжить разбор и отображение документа. Такой !!синхронный, или !!блокирующий, порядок выполнения действует только по умолчанию. Тег <script> может иметь атрибуты !!defer и !!async, которые (в браузерах, поддерживающих их), определяют иной порядок выполнения сценариев. Согласно HTML5, эти атрибуты принимаются во внимание, только когда используются вместе с атрибутом src, однако некоторые браузеры могут поддерживать атрибут defer и для встроенных сценариев.

Оба атрибута, и defer и async, сообщают браузеру, что данный сценарий не использует метод document.write() и не генерирует содержимое документа, а что браузер может продолжать разбор и отображение документа, пока сценарий загружается. Атрибут !!defer сообщает браузеру, что нужно сначала загрузить документ, потом выполнить сценарий. Атрибут !!async сообщает, что можно продолжить разбор документа, и нужно выполнить сценарий как только это станет возможно. При этом предпочтение отдается атрибуту async.

Отложенные сценарии выполняются в порядке их следования в документе. Асинхронные сценарии выполняются сразу как только будут загружены, т.е. они могут выполняться в произвольном порядке.

!3 Последовательность выполнения клиентских сценариев

};
* Браузер создает объект Document и начинает разбор страницы, добавляя в документ объекты Element и текстовые узлы в ходе синтаксического анализа HTML-элементов и их текстового содержимого. На этой стадии свойство document.readyState получает значение loading.
* Когда механизм синтаксического анализа HTML встречает элементы <script>, не имеющие атрибута async и defer, он добавляет эти элементы в документ и затем выполняет встроенные или внешние сценарии. Эти сценарии выполняются синхронно, а на время, пока сценарий загружается (если это необходимо) и выполняется, синтаксический анализ документа приостанавливается. Такие сценарии могут использовать метод document.write() для вставки текста во входной поток. Этот текст станет частью документа, когда синтаксический анализ продолжится. Синхронные сценарии часто просто определяют функции и регистрируют обработчики событий для последующего использования, но они могут исследовать и изменять дерево документа, доступное на момент их запуска. То есть, синхронные сценарии могут видеть собственный элемент <script> и содержимое документа перед ним.
* Когда механизм синтаксического анализа встречает элемент <script>, имеющий атрибут async, он начинает загрузку сценария и продолжает разбор документа. Сценарий будет выполнен сразу же по окончании его загрузки, но синтаксический анализ документа не приостанавливается на время загрузки сценария. Асинхронные сценарии не должны использовать метод document.write(). Они могут видеть собственный элемент <script>, все элементы документа, предшествующие ему, и возможно дополнительное содержимое документа.
* По окончании анализа документа свойство document.readyState изменяется на "interactive".
* Выполняются все сценарии, имеющие атрибут defer, в том порядке, в каком они встречаются в документе. В этот момент также могу выполняться асинхронные сценарии. отложенные сценарии имеют доступ к полному дереву документа и не должны использовать метод document.write().
* Браузер возбуждает событие DOMContentLoaded в объекте Document. Это событие отмечает переход от этапа синхронного выполнения сценариев к управляемому событиями асинхронному этапу выполнения программы. Следует отметить, что в этот период также могу выполняться асинхронные сценарии, которые еще не были выполнены.
* К этому моменту синтаксический анализ документа завершен, но браузер все еще может ожидать окончания загрузки дополнительного содержимого, такого как изображения. Когда все содержимое будет загружено и все асинхронные сценарии будут выполнены, свойство document.readyState получит значение "complete" и браузер возбудит событие "load" в объекте Window.
* С этого момента будут асинхронно вызываться обработчики событий в ответ на действия пользователя, сетевые операции, истечение таймера и т.д.
;}

!2 Совместимость на стороне клиента

Проблемы совместимости на стороне клиента делятся на три основные категории:

:}
* !!Эволюционные.
* !!Отсутствие !!реализации.
* !!Ошибки.
:}

Ресурсы:

{-
code.google.com}doctype
Энциклопедия открытой сети. Содержит сведения о существовании различных свойств и методов в различных браузерах.

en.wikipedia.org}wiki}Comparison_of_layout_engines_(HTML_5)
Статья, описывающая реализацию HTML5 в браузерах.

en.wikipedia.org}wiki}Comparison_of_layout_engines_(Document_Object_Model)
Статья, описывающая степень реализации особенностей DOM в браузерах.

a.deveria.com}caniuse
Предоставляет информацию о реализации важных веб-особенностей, позволяя фильтровать ее по различным критериям.

www.quirksmode.org}com
Содержит таблицы совместимости различных браузеров со спецификациями W3C DOM.

webdevout.net}browser-support
Предоставляет информацию и реализации веб-стандартов различными производителями.
-}

Одна из стратегий разрешения несовместимостей заключается в использовании только тех возможностей, которые хорошо реализованы на всех платформах.

!3 Библиотеки обеспечения совместимости

Для обеспечения совместимости можно использовать сторонние библиотеки, которые используют обходные пути для реализации отсутствующих возможностей.

!3 Классификация браузеров

!!Классификация !!браузеров - это прием тестирования и оценки качества, введенный компанией Yahoo!. Данная технология разделяет браузеры на категории A, C и X. A - стандартизированные браузеры, которые получают полнофункциональные версии приложений. C - менее мощные браузеры, в которых отсутствуют некоторые или все возможности, они получают минимальные HTML страницы. X - неизвестные или новые браузеры, как правило получают полнофункциональные версии приложений, но не тестируются.

!3 Проверка особенностей

Данная стратегия заключается в том, чтобы проверять наличие используемых возможностей и при отсутствии не использовать их или реализовывать обходные пути.

!3 Режим совместимости и стандартный режим

Большинство современных браузеров реализуют два режима отображения: режим совместимости и стандартный режим.

Определить текущий режим можно с помощью свойства document.compatMode. Если оно имеет значение "CSS1Compat", документ отображается в стандартном режиме. Если оно имеет значение "BackCompat"(или undefined, если такое свойство вообще не существует), документ отображается в режиме совместимости. Данное свойство стандартизировано спецификацией HTML5.

!3 Проверка типа браузера

Для разрешения ошибок и несовместимостей конкретных браузеров, бывает необходимо разработать программный код, который должен выполняться только в браузерах определенного производителя, определенного номера версии или в конкретной операционной системе (либо в конкретной комбинации всех трех признаков). На стороне клиента это можно сделать с помощью объекта Navigator.

Программный код, который определяет производителя и версию браузера, часто называюют анализатором браузера (browser sniffer) или анализатором клиента (client sniffer). 

!3 Условные комментарии в Internet Explorer

{-
<!--[if IE 6]>
Эти строки фактически находятся внутри HTML-комментария.
Они будут отображаться только в IE6.
<![endif]-->

<!--[if lte IE 7]>
Эта строка будет отображена только в IE 5, 6, 7 и в более ранних версиях.
lte обозначает "less than or equal" (меньше или равно). Можно также использовать "lt", "gt" и "gte".
<!endif-->

<!--[if !IE]> <-->
Это обычное HTML-содержимое, но IE не будет отображать его из-за комментариев, что расположены выше и ниже.
<!--> <![endif]-->
-}

Условные комментарии также поддерживаются интерпретатором JavaScript в IE. Условные JavaScript-комментарии в IE начинаются с комбинации символов }*@cc_on и завершаются комбинацией @*}.

{-
}*@cc_on
	@if (@_jscript)
	// Следующий код находится внутри JS-комментария, но IE выполнит его.
	alert('In IE');
@*}
-}

Внутри условных комментариев могут указываться ключевые слова @if, @else и @end, предназначенные для отделения программного кода, который должен выполняться интерпретатором JavaScript в IE по определенному условию. JScript - это название интерпретатора JavaScript, которое было дано ему в Microsoft, а переменная @_jscript в IE всегда имеет значение true.

При грамотном чередовании условных и обычных комментариев можно определить, какой блок программного кода должен выполняться в IE, а какой - во всех остальных браузерах:

{-
}*@cc_on
	@if (@_jscript)
		// Этот блок кода находится внутри условного комментария, который также является обычгым JavaScript-комментарием. В IE этот блок будет выполнен, а в других браузерах - нет.
		alert('Вы пользуетесь Internet Explorer');
	@else}*
		// Этот блок уже не находится внутри JavaScript-комментария, но по-прежнему находится внутри условного комментария IE. Вследствие этого данный блок кода будет выполнен всеми браузерами, кроме IE.
		alert('Вы не пользуетесь Internet Explorer');
@*}
-}

!2 Безопасность

!3 Чего не может JavaScript

Первой линией обороны в борьбе со злонамеренным JavaScript-кодом является отсутствие некоторых функций в клиентском JavaScript. Например, нельзя напрямую работать с файлами, обращаться к сети и т.д.

Вторая линия обороны - это ограничение существующих функций, например:

:}
* Ограничение на открываемые всплывающие окна (большинство браузеров разрешают их, только если они вызваны непосредственно в ответ на действия пользователя).
* JavaScript-программа может закрыть окно браузера, открытое ею же, но она не может закрыть другое окно без подтверждения пользователя.
* Свойство value HTML-элемента FileUpload не может быть установлено программно.
* Сценарий не может прочитать содержимое документов с других серверов, отличных от сервера, откуда был получен документ с данным сценарием. Аналогично сценарий не может зарегистрировать обработчики событий в документах, полученных с других серверов. Это ограничение известно как политика общего происхождения (same-origin policy).
:}

!3 Политика общего происхождения

Это радикальное ограничение, накладываемое на веб-содержимое, с которым может взаимодействовать JavaScript-код. Сценарий может читать только свойства тех окон и документов, имеющих общее с самим сценарием происхождение.

!!Происхождение документа определяется протоколом, именем хоста и номером порта URL-адреса, откуда был загружен документ. Документы, загружаемые с других веб-серверов, имеют другое происхождение. Документы, загруженные с разных портов одного и того же хоста также имеют друое происхождение. Наконец, документы, загруденные по протоколу http:, по происхождению отличаются от документов, загруженных по протоколу https, даже если загружены с одного и того же сервера.

При этом, происхождение самого сценария не имеет никакого значения: имеет значение только происхождение документа, в который встраивается сценарий.

Политика общего происхождения ограничивает доступ не ко всем свойствам.

!3 Ослабление ограничений политики общего происхождения

Для ослабления ограничений можно использовать свойство document.domain. По умолчанию это свойство содержит имя сервера, с которого был загружен документ. Это свойство можно установить только равным строке, являющейся допустимым доменным суффиксом первоначального значения.

Если два окна (или фрейма) содержат сценарии, установившие одинаковые значения свойства domain, политика общего происхождения для этих двух окон ослабляется, и каждое из окон может читать значения свойств другого окна.

!3 Межсайтовый скриптинг

Универсальный способ предотвращения XSS-атак заключается в удалении HTML-тегов из всех данных сомнительного происхождения, прежде чем использовать их для динамического создания содержимого документа.

!3 Атаки типа отказа в обслуживании

Сценарий может порождать бесконечные циклы с бессмысленными вычислениями или другие конструкции, чрезмерно нагружающие процессор.