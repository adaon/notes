!1 Работа с протоколом HTTP

Ajax-взаимодействие можно реализовать несколькими путями. Например, можно изменять атрибут src тега <img>, тогда браузер инициирует http-запрос на сервер. Кроме того, можно изменять атрибут src тега <iframe>, в таком случае содержимое фрейма станет ответом сервера на запрос.

Также для этого может использоваться тег <script> (данные теги могут использоваться для взаимодействия с другими серверами). В таком случае ответом сервера является JSON. Данный транспорт называется JSONP.

!2 Использование объекта XMLHttpRequest

Каждый экземпляр этого класса представляет единственную пару запрос/ответ, а свойства и методы объекта позволяют определять параметры запроса и извлекать данные из ответа.

{-
var request = new XMLHttpRequest();
-}

Допустимо повторно использовать уже имеющийся экземпляр объекта XMLHttpRequest, но в этом случае будет прервано выполнение запроса, уже отправленного браузером

HTTP-запрос состоит из четырех частей:

{:
* Метод HTTP-запроса или тип "операции".
* Запрашиваемые URL-адрес.
* Необязательные заголовки запроса, которые могут включать информацию для аутентификации.
* Необязательное тело запроса.
:}

HTTP-отве, возвращаемый сервером, состоит из трех частей:

{:
* Числовое и текстовое значение, определяющее код состояния, свидетельствующий об успехе или ошибке.
* Набор заголовков ответа.
* Тело ответа.
:}

!3 Выполнение запроса

Установка параметров запроса:

{-
request.open('GET', '/mydata/'); // Принимает метод запроса и URL ресурса.
-}

Установка заголовков запроса, если это необходимо:

{-
request.setRequestHeader('Content-Type', 'text/plain'); // Если вызвать данный метод несколько раз для одного и того же заголовка, значение заголовка не будет изменено: вместо этого будет вставлено несколько копий заголовка или один заголовок с несколькими значениями.
-}

Нельзя определять собственные заголовки Content-Length, Date, Referer и User-Agent: объект XMLHttpRequest Добавляет их автоматически и не позволяет подделывать их. Он также автоматически обрабатывает cookies и срок поддержки открытого соединения, определяет кодировку символов и выполняет кодирование сообщений, поэтому не должны устанавливаться следующие заголовки:

{-
Accept-Charset
Accept-Encoding
Connection
Content-Length
Cookie
Cookie2
Content-Transfer-Encoding
Date
Expect
Host
Keep-Alive
Referer
TE
Trailer
Transfer-Encoding
Upgrade
User-Agent
Via
-}

При выполнении запроса к ресурсу, защищенному паролем, нужно передать имя пользователя и пароль методу open() в четвертом и пятом аргументах.

Передача необязательного тела запроса и отправка его серверу:

{-
request.send(null); // GET-запросы не имеют тела, поэтому передается null.
-}

POST-запросы обычно имеют тело, и оно должно соответствовать заголовку Content-Type, установленному с помощью метода setRequestHeader().

Все методы должны вызываться именно в таком порядке.

!3 Получение ответа

Полный HTTP-ответ содержит код состояния, набор заголовков ответа и тело ответа. Все это доступно в виде свойств и методов объекта XMLHttpRequest:

{:
* Свойства !!status и !!statusText возвращает код состояния HTTP  в числовом и текстовом виде. Эти свойства хранят стандартные HTTP-значения.
* Заголовки ответа можно получить с помощью методов !!getResponseHeader() и !!getAllResponseHeaders(). Обработка cookies выполняется объектом XMLHttpRequest автоматически: он исключает заголовки Cookie из множества, возвращаемого методом getAllResponseHeaders(), и возвращает null, если передать аргумент Set-Cookie или Set-Cookie2 методы getResponseHeader().
* Тело ответа в текстовом виде доступно через свойство !!responseText или в виде объекта Document через свойство !!responseXML.
:}

Данные методы и свойства не могут использоваться до фактического получения ответа. Чтобы определить момент получения ответа, необходимо обрабатывать событие !!readystatechange (или !!progress), возбуждаемое в объекте XMLHttpRequest.

Свойство readyState - это целочисленное значение, определяющее код состояния HTTP-запроса.

{-
UNSENT				0	Метод open() еще не был вызван.
UPENED				1	Метод open() был вызван.
HEADERS_RECEIVED	2	Были получены заголовки.
LOADING				3	Идет прием тела ответа.
DONE				4	Прием ответа завершен.
-}

Теоритически событие readystatechange генерируется всякий раз, когда изменяется значение свойства readyState. На практике же оно может не возбуждаться, когда свойство readyState получает значение 0 или 1. Оно часто возбуждается при вызове метода send(), даже при том, что readyState по-прежнему содержит значение OPENED. Некоторые события возбуждают событие множество раз для состояния LOADING, чтобы обеспечить обратную связь. Все браузеры возбуждают событие readystatechange, когда завершается прием ответа сервера и свойство readyState получает значение 4.

{-
request.onreadystatechange = function() {
	if(request,readyState == 4 && request.status == 200) {
		var type = request.getResponseHeader('Content-Type');
		if(type.match(/^text/))
		mycallback(request.responseText);
	}
};
-}

!3 Получение синхронного ответа

{-
request.open('GET', '/my/',  false); // Если в третьем аргументе передать false, выполнение метода send() будет заблокировано до завершения запроса.
-}

!3 Декодирование ответа

Если сервер посылает в ответе XML- или XHTML-документ, разобранное представление XML-документа можно получить из свойства responseXML. Значением этого свойства является объект Document.

Для корректного декодирования ответа сервера необходимо, чтобы сервер отправлял заголовок Content-Type с правильным значением MIME-типа ответа. Если сервер не укажет тип, объект XMLHttpRequest не произведет синтаксический анализ документа и не установит значение свойства responseXML или responseText. Или, если сервер укажет неправильное значение в параметре charset заголовка Content-Type, объект XMLHttpRequest декодирует ответ с использованием неправильной кодировки и в свойстве responseText могут оказаться ошибочные символы.

Спецификация XHR2 определяет метод !!overrideMimeType(), предназначенный для решения этой проблемы, и он уже реализован в некоторых браузерах. Если необходимо определить MIME-тип, лучше подходящий для веб-приложения, чем возвращаемый сервером, можно перед вызовом методаs send() передать методу overrideMimeType() свой тип - это заставит объект XMLHttpRequest проигнорировать заголовок Content-Type и использовать указанный тип.

!3 Оформление тела запроса

{#Запросы с данными в формате HTML-форм:#}

Тело запроса вида "name1=value&name2=value" получается путем URL-кодирования и соответствует формальному MIME-типу:

{-
application/x-www-form-urlencoded
-}

Этот тип следует указать в заголовке Content-Type запроса при отправке данных такого вида в составе запроса методом POST.

{#Запросы с данными в формате JSON:#}

{-
request.setRequestHeader('Content-Type', 'application/json');
request.send(JSON.stringify(data));
-}

{#Запросы с данными в формате XML:#}

Методу send() можно передать объект Document простого XML-документа и использовать его в качестве тела HTTP-запроса.

{-
var doc = document.implementation.createDocument('', 'query', null);
var query = doc.documentElement;
var find = doc.createElement('find');
query.appendChild(find);
// Отправить данные в формате XML серверу.
// Заголовок Content-Type будет установлен автоматически.
request.send(dov);
-}

Аналогично, если передать методу send() простую строку и не установить заголовок Content-Type, объект XMLHttpRequest автоматически добавит этот заголовок со значением "text/plain; charset=UTF-8".

{#Выгрузка файлов:#}

Прикладной интерфейс, определяемый спецификацией XHR2, позволяет выгружать файлы за счет передачи объекта File методу send().

В браузерах, поддерживающих объекты File, каждый элемент <input type="file"> имеет свойство files, которое ссылается на объект, подобный массиву, хранящий объекты File. Прикладной интерфейс перетаскивания также позволяет получить доступ к файлам, сбрасываемым пользователем на элемент, через свойство dataTransfer.files события drop.

{-
request.open('POST', url);
request.send(file);
-}

Тип File является подтипом более общего типа blob. Спецификация XHR2 позволяет передавать методу send() произвольные объекты Blob. Свойство type объекта Blob в этом случае будет использоваться для установки заголовка Content-Type, если он не будет определен явно.

{#Запросы с данными в формате multipart/form-data#}

Спецификация XHR2 определяет новый прикладной интерфейс FormData, упрощающий создание тела запроса, состоящего из нескольких частей. Сначала с помощью конструктора создается объект FormData, а затем вызовом метода append() в него добавляются отдельные части (File или Blob). В заключение объект FormData передается методу send(). Метод send() определит соответствующую строку, обозначающую границу, и установит заголовок Content-Type запроса.

{-
var formdata = new FormData();
formdata.append(name, value); // Добавить имя/значение как одну часть.Допускается использовать объекты File.
request.send(formdata); // Отправить пары имя/значение в теле запроса multipart/form-data. Каждая пара - это одна часть тела запроса. Заголовок Content-Type устанавливается автоматически.
-}

!3 События, возникающие в ходе выполнения HTTP-запроса

Проект спецификации XHR2 определяет более удобный набор событий, уже реализованный в Firefox, Chrome и Safari. В этой новой модели событий объект XMLHttpRequest генерирует различные типы событий на разных этапах выполнения запроса, благодаря чему отпадает необходимость проверять значение свойства readyState.

{!
loadstart -- Возбуждается один раз, когда вызывается метод send().
progress -- Возбуждается периодически (обычно каждые 50 миллисекунд) в ходе загрузки ответа сервера. Если запрос завершается очень быстро, событие progress может и не возбуждаться.
load -- Возбуждается по завершении запроса. Обработчик данного события должен проверять код состояния.
abort -- Возникает при прерывании запроса пользователем.
timeout -- Генерируется, если предельное время ожидания ответа истекло.
error -- Генерируется при возникновении ошибок в сети, таких как слишком большое количество переадресаций.
!}

Для каждого запроса браузер может возбуждать только по одному событию load, abort, timeout и error. Проект спецификации также требует, чтобы после возникновения одного из этих событий возбуждалось событие loadend, однако на текущий момент ни один браузер не поддерживает его.

Объект события, связанный с этими событиями, возникающими в ходе выполнения запроса, в дополнеине к свойствам обычного объекта Event, таким как type и timestamp, добавляет три полезных свойства. Свойство !!loaded определяет количество байтов, переданных к моменту возбуждения события. Свойство !!total содержит общий объем (в байтах) загружаемых данных, определяемый из заголовка Content-Length, или 0, если объем содержимого неизвестен. Свойство !!lengthComputable содержит значение true, если общий объем содержимого известен, и false - в противном случае.

{#События, возникающие в ходе выгрузки:#}

В браузерах, реализующих эту возможность, объект XMLHttpRequest имеет свойство upload. Значением данного свойства является объект, определяющий метод addEventListener() и полный набор свойств-событый хода выполнения операции выгрузки, таких как onprogress и onload.

!3 Прерывание запросов и предельное время ожидания

{-
request.abort(); // Прерывание запроса. Согласно XHR2 генерирует событие abort.
-}

Спецификация XHR2 определяет свойство !!timeout, в котором указывается промежуток времени в миллисекундах, после которого запрос будет автоматически прерван. После истечения данного времени будет возбуждено событие timeout.

!3 Выполнение междоменных HTTP-запросов

Будучи субъектом политики общего происхождения, объект XMLHttpRequest может использоваться для отправки HTTP-запросов только серверу, откуда был получен использующий его документ.

Спецификация XHR2 позволяет выполнять междоменные запросы к другим веб-сайтам, указанным в заголовке CORS (Cross-Origin Resource Sharing) HTTP-ответа.

{!Пропущено:552-554!}

!2 Выполнение HTTP-запросов с помощью <script>: JSONP

{!Пропущено:555-557!}

!2 Архитектура Comet на основе стандарта "Server-Sent Events"

{!Пропущено:557-562!}