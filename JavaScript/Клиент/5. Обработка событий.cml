!1 Обработка событий

!2 Типы событий

Категории событий:

{!
Аппаратно-зависимые средства ввода -- События из этой категории непосредственно связаны с конкретными устройствами ввода, такими как мышь или клавиатура. В эту категорию входят такие события как !!mouse down, !!mousemove, !!mouseup, !!keydown, !!keypress, !!keyup, а также новые события, имеющие отношение к сенсорным устройствам, такие как !!touchmove и !!gesturechange.
Аппаратно-независимые события ввода -- Эти события ввода не связаны непосредственно с каким-то определенным устройством. Например, событие !!click указывает на то, что была активирована ссылка или кнопка (или другой элемент документа). Событие !!textinput (которое пока реализовано не во всех браузерах) является аппаратно-независимой альтернативой событию !!keypress и поддерживает не только ввод с клавиатуры, но и такие альтернативы, как вставка из буфера обмена и ввод рукописного текста.
События пользовательского интерфейса -- Это высокоуровневые события, которые часто возникают в элементах HTML-форм, составляющих пользовательский интерфейс веб-приложения. В эту категорию входит событие !!focus, !!change, !!submit.
События изменения состояния -- События, которые не связаны непосредственно с деательностью пользователя, но имеют отношение к выполнению сетевых операций браузером и указывают на переход к другому этапу операции или на изменение состояния. Наиблее часто используемым является событие !!load, которое возбуждается в объекте Window по окончании загрузки документа. Также это событие !!DOMContentLoaded. Механизм управления историей посещений, определяемый стандартом HTML5, возбуждает событие !!popstate в ответ на нажание клавиши Back браузера. Прикладной интерфейс автономных приложений, описываемый стандартом HTML5, включает события !!online и !!offline. Событие !!readystatechange сообщает о получении данных с сервера. Новый API чтения локальных файлов, выбранных пользователем, использует события, такие как !!loadstart, !!progress и !!loadend для отправки асинхронных извещений о ходе выполнения операций ввода-вывода.
Прикладные события -- Некоторые прикладные интерфейся, определяемые стандартом HTML5 и связанными с ним спецификациями, включают собственные типы событий. Интерфейс drag-and-drop определяет такие события как !!dragstart, !!dragenter, !!dragover и !!drop. Элементы <video> и <audio>, определяемые стандартом HTML5, добавляют длинный список связанных с ними типов событий, таких как !!waiting, !!playing, !!seeking, !!volumechange и т.д.
Обработчики ошибок и событий от таймеров -- Являются частью асинхронной модели программирования и похожи на обработчики обычных событий.
!}

!3 События форм

События форм являются наиболее устойчивыми и хорошо поддерживаемыми из всех типов событий.

{!
submit -- При отправке формы.
reset -- Перед сбросом формы в исходное состояние.
click -- Возбуждается элементами форм, когда пользователь взаимодействует с ними.
change -- Когда пользователь изменяет состояние элементов, вводя текст, выбирая элемент списка или отмечая флажок. Для текстовых элементов данное событие не возбуждается, пока пользователь не завершит взаимодействие с ними и не передаст фокус ввода другому элементу.
focus -- Получение фокуса.
blur -- Потеря фокуса.
!}

Для событий submit и reset предусматриваются действия по умолчанию, выполнение которых можно отменить в обработчиках событий, как и в случае некоторых событий click. Все события форм всплывают, кроме событий focus и blur. IE определяет события !!focusin и !!focusout, которые являются всплывающими альтернативами событий focus и blur. Кроме того, эти события были стандартизированы спецификацией "DOM Level 3 Events".


Все браузеры кроме IE возбуждают событие !!input в элементах textarea и других текстовых элементах, когда пользователь вводит текст в элемент. Данное событие возбуждается при каждой вставке.

!3 События объекта Window

{!
load -- Возбуждается сразу после того, как будут загружены и отображены документ и все внешние ресурсы (такие как изображения).
unload -- Возбуждается, когда пользователь покидает документ.
beforeunload -- Похоже на событие unload, но оно дает возможность узнать у пользователя, действительно ли он желает покинуть страницу. Если обработчик данного события вернет строку, эта строка будет выведена в диалоге подтверждения перед тем, как будет загружена новая страница. Этот диалог дает пользователю возможность отменить переход и остаться на текущей странице.
onerror -- Данное свойство объекта Window является своего рода обработчиком событий, который вызывается в случае появления ошибок в программном коде на языке JavaScript. Однако, это не настоящий обработчик событий, потому что он вызывается совсем с другим набором аргументов.
focus, blur -- Возбуждаются, когда текущее окно браузера получает или теряет фокус ввода.
resize -- Когда выполняется изменение размеров окна. Объект события не представляет свойств, содержащих новый размер окна.
scroll -- Когда выполняется прокрутка окна браузера. Объект события не представляет свойств, содержащих информацию о прокрутке.
!}

Имеется также возможность регистрировать обработчики событий !!load и !!error для отдельных элементов документа, таких как <img>. Эти события возбуждаются, когда внешний ресурс (например, изображение) будет полностью загружен или когда возникнет ошибка, препятствующая загрузке. Некоторые браузеры поддерживают событие !!abort (стандартизированное спецификацией HTML5), которое возбуждается, когда загрузка изображения (или другой ресурс, загружаемый из сети) прерывается из-за того, что пользователь остановил процесс загрузки.

!3 События объекта Document

{!
DOMContentLoaded -- Возбуждается, как только документ будет загружен, разобран синтаксическим анализатором, и будут выполнены все отложенные сценарии. Поддерживается в IE>8.
readystatechange -- Возбуждается при изменении значения свойства document.readyState.
!}

!3 События мыши

СОбытия мыши возбуждаются, когда пользователь перемещает указатель мыши или выполняет щелчок. Эти события генерируются в наиболее глубоко вложенных элементах, над которыми находится указатель мыши, но они всплывают вверх по дереву документа.

Объект события:

{!
event.clientX, event.clientY -- Определяют положение указателя мыши в системе координат окна.
event.button, event.which -- Позволяют узнать, какая кнопка была нажата.
event.altKey, event.ctrlKey, event.metaKey, event.shiftKey -- Получают значение true, если в момент возникновения события удерживалась нажатой соответствуюзая клавиша-модификатор.
event.detail -- Для события click указывает, был ли выполнен одинарный, двойной или тройной щелчок.
!}

События мыши:

{!
mousemove -- Генерируется всякий раз, когда пользователь перемещает указатель мыши. Это событие возбуждается очень часто, поэтому его обработчики не должны выполнять тяжелые вычисления.

mousedown, mouseup -- Генерируются, когда пользователь нажимает и отпускает кнопку мыши.

click -- Генерируется после последовательности событий mousedown и mouseup.

dblclick -- Возбуждается вторым щелчком двойного щелчка.

contextmenu -- Отменяемое событие, генерируется при щелчке правой кнопкой мыши, перед выводом контекстного меню.

mouseover -- Когда пользователь перемещает указатель мыши так, что он оказывается над другим элементом. Объект события содержит свойство !!relatedTarget (в IE - !!fromElement), которое содержит элемент, с которого пришел указатель.

mouseout -- Когда указатель мыши покидает границы элемента. Объект события содержит свойство !!relatedTarget (в IE - !!toElement), которое содержит элемент, на который переместился указатель.

mouseenter, mouseleave -- Невсплывающие версии событий mouseover и mouseout. Поддерживаются не всеми браузерами (кроме того, эмулируются в jQuery).
!}

!3 События колесика мыши

События:

{!
mousewheel -- Когда пользователь вращает колесико мыши (в Firefox - !!DOMMouseScroll). Объект события, имеет свойство wheelDelta, определяющее величину прокрутки колесика (один шаг обычно составляет 120).
!}

!3 События перетаскивания (drag-and-drop)



!3 События клавиатуры

Когда браузер получает фокус ввода, он начинает генерировать события всякий раз, когда пользователь нажимает и отпускает клавиши на клавиатуре. Нажатия горячих клавиш, имеющий значение для операционной системы или самого браузера, часто "съедаются" операционной системой или браузером и не передаются обработчикам событий на JavaScript. События клавиатуры генерируются в любом элементе документа, обладающем фокусом ввода, и всплывают вверх до объектов документа и окна. Если ни один элемент не обладает фокусом ввода, события возбуждаются непосредственно в объекте документа.

Объект события:

{!
event.keyCode -- Какая клавиша была нажата или отпущена.
vent.altKey, event.ctrlKey, event.metaKey, event.shiftKey -- Описывают состояние клавиш-модификаторов.
!}

События:

{!
keydown, keyup -- Низкоуровневые события клавиатуры. Генерируются, когда производится нажатие или отпускание клавиши (даже если это клавиша-модификатор).
keypress -- Когда событие keydown генерируется нажатием клавиши, соответствующей печатаемому символу, после события keydown, но перед событием keyup. В случае если клавиша удерживается в нажатом остоянии настолько долго, что начинается автоповтор символа, перед событием keyup будет сгенерировано множество событий keypress. Является высокоуровневым событием ввода текста и соответствующий ему объект события содержит информацию о введенном символе, а не о нажатой клавише.
!}

Данные события поддерживаются всеми браузерами, однако существуют некоторые проблемы совместимости из-за того, что не были стандартизированы значения свойства keyCode объекта события.

{!Пропущено:522-530!}

!3 События модели DOM

Спецификация "DOM Level 3 Events" стандартизирует многие из старых событий и добавляет несколько новых событий. Эти новые типы событий пока не получили широкой поддержки, но производители браузеров предполагают реализовать их к моменту окончательного утверждения стандарта.

Спецификация стандартизирует события !!focusin и !!focusout, !!mouseenter, !!mouseleave как невсплывающие альтернативы старых событий.

{!
wheel -- Обработчик события колесика мыши. Объект события содержит все свойства, обычные для объектов событий мыши, а также свойства deltaX, deltaY и deltaZ, позволяющие узнать величину прокрутки вокруг трех разных осей колесика мыши.
textinput -- Рекомендуется использовать вместо keypress. Объект события содержит свойство data, содержащее введенную строку текста. Свойство объекта события inputMethod содержит константу, определяющую метод ввода (с клавиатуры, копированием из буфера обмена и т.д.).
!}

Новый стандарт также упрощает события !!keydown, !!keyup и !!keypress, добавляя новые свойства key и char в объект события. Оба эти свойства содержат строковые значения. Для клавиш, генерирующих печатаемые символы, свойства key и char будут хранить один и тот же сгенерированный текст. Для управляющих клавиш свойство key будет хранить строку "Enter", "Delete" или "Left", идентифицирующую клавишу. А свойство char будет хранить либо значение null, либо строку, сгенерированную клавишей. На момент написания этих строк ни один браузер не поддерживал эти свойства.

!3 События HTML5

События <audio> и <video>:

{-
canplay
canplaythrough
durationchange
emptiedd
ended
loadeddata
loadedmetadata
loadstart
pause
play
playing
progress
ratechange
seeked
seeking
stalled
suspend
timeupdate
volumechange
waiting
-}

Эти события, имеющие отношение к медиапроигрывателям, передаются в виде простого объекта события, не имеющего специальных свойств. Однако свойство !!target идентифицирует элемент <audio> или <video>, и этот элемент имеет множество специфических свойств и методов.

Интерфейс перетаскивания, определяемый стандартом HTML5, определяет следующие семь типов событий:

{-
dragstart
dragenter
drop
drag
dragover
dragend
dragleave
-}

Эти события сопровождаются объектами событий, подобными тем, что передаются вместе с событиями мыши. Отличаются они единственным дополнительным свойством !!dataTransfer, хранящим объект DataTransfer с информацией о передаваемых данных и о форматах, в которых эти данные доступны.

Спецификация HTML5 также определяет механизм управления историей посещений, который вводит события с именами !!hashchange и !!popstate.

События автономных приложений:

{-
offline
online
cached
noupdate
checking
obsolete
downloading
progress
error
updateready
-}

Событие !!message используется множеством новых API. При передаче сообщения в объекте Window документа принимающего сообщение, генерируется событие !!message. Объект события, передаваемый обработчику, включает свойство !!data, хранящее содержимое сообщения, а также свойства !!source и !!origin, идентифицирующие отправителя сообщения. Данное событие также используется для взаимодействия с фоновыми потоками WebWorkers и для сетевых взаимодействий.

Версия 2 спецификации XMLHttpRequest, а также спецификация File API определяют множество событий, помогающих следить за ходом выполнения асинхронных операций ввода/вывода. Эти события генерируются в объектах XMLHttpRequest или FileReader. Каждая операция чтения начинается с события !!loadstart, за которым следует последовательность событий !!progress и событие !!loadend. Кроме того, каждая операция завершается событием !!load, !!error или !!abort, генерируемым непосредственно перед заключительным событием loadend.

Спецификация Web Storage API определяет событие !!storage (генерируемое в объекте Window), извешающее об изменении хранимых данных.

В спецификации HTML5 также определены события !!beforeprint и !!afterprint.

!3 События, генерируемые сенсорными экранами и мобильными устройствами

{!Пропущено: 495-496!}

!2 Регистрация обработчиков событий

!3 Установка свойств обработчиков событий

{-
window.onload = function() {
	element.onsubmit = function() {};
};
-}

Такой способ регистрации обработчиков поддерживается по всех браузерах для часто используемых типов событий.

!3 Установка атрибутов обработчиков событий

{-
<button onclick="alert('Hello!');"></button>
-}

Обработчики событий элемента Window должны помещаться в тег <body>:

{-
onafterprint
onbeforeprint
onbeforeunload
onblur
onerror
onfocus
onhashchange
onload
onmessage
onoffline
ononline
onpagehide
onpageshow
onpopstate
onredo
onresize
onstorage
onundo
onunload
-}

Когда в качестве значения атрибута обработчика события в разметке HTML указывается строка с программным кодом на языке JavaScript, браузер преобразует эту строку в функцию, которая будет выглядеть примерно так:

{-
function(event) {
	with(document) {
		with(this.form || {}) {
			with(this) {
				// Ваш программный код
			}
		}
	}
}
-}

Если браузер поддерживает ECMAScript 5, функция определяется в нестрогом режиме.

!3 addEventListener()

В стандартной модели событий, поддерживаемой всеми браузерами кроме IE 8 и ниже, целью события может быть любой объект - включая объекты Window, Document и все объекты Element. Метод addEventListener() принимает три аргумента: тип события, функция-обработчик и логическое значение, определяющее фазу события. Если false - обработчик вызывается при всплытии, если true - при перехвате.

{-
var handler = function() {};
elem.addEventListener('myevent', handler, false); // Добавление обработчика.
elem.removeEventListener('myevent', handler, false); // Удаление обработчика.
-}

!3 attachEvent()

Данные методы подерживает IE начиная с 5 версии:

{-
elem.arrachEvent('onmyevent', handler);
elem.detachEvent('onmyevent', handler);
-}

По своему действию данные методы похожи на методы addEventListener() и removeEventListener() со следующими исключениями:

{:
* Поскольку модель событий в IE не поддерживает фазу перехвата, методы attachEvent() и detachEvent() принимают только два аргумента.
* В первом аргументе передается имя свойства обработчика события с префиксом "on".
* Метод attachEvent() позволяет зарегистрировать одну и ту же функцию обработчика несколько раз. При возникновении события указанного типа зарегистрированная функция будет вызвана столько раз, сколько она была зарегистрирована.
:}

!2 Вызов обработчиков событий

!3 Аргумент обработчика событий

При вызове обработчика событий ему обычно передается объект события в виде единственного аргумента. Его свойство !!type определяет тип возникшего события.

В IE версии 8 и ниже обработчикам событий, зарегистрированным установкой свойства, объект события при вызове не передается. Вместо этого объект события сохраняется в глобальной переменной с именем window.event. Для совместимости обработчики нужно оформлять так:

{-
function handler(event) {
	event = event || window.event;
}
-}

Оьъект события передается обработчикам событий, зарегистрированным с помощью метода attachEvent(), но они также могут использовать переменную window.event.

При регистрации обработчика события посредством HTML-атрибута браузер преобразует строку с программным кодом на языке JavaScript в функцию. Браузеры, отличные от IE, создают функцию с единственным аргументом event. В IE создается функция, не принимающая аргументов. Если в таких функциях использовать идентификатор event, он будет ссылаться на window.event. В любом случае обработчики событий, определяемые в разметке HTML, могут ссылаться на объект события, используя идентификатор event.

!3 Контекст обработчиков событий

В теле обработчика событий ключевое слово this ссылается на цель события. Если обработчик регистрируется с помощью метода attachEvent(), он вызывается как функция, и в нем ключевое слово this ссылается на глобальный объект.

!3 Область видимости обработчика событий

Также как и другие функции, обработчики событий имеют лексическую область видимости.

Обработчики событий, определяемые посредством HTML-атрибутов, могут использовать свойства целевого объекта, объемлючего элемента <form> (если таковой имеется) и объекта Document, как если бы они были локальными переменными. Это значит, что свойства всех объектов в цепочке видимости скрывают одноименные свойства глобального объекта.

!3 Возвращаемые значения обработчиков

Если обработчик регистрируется через HTML-аттрибут или свойство, возвращаемое им значение false обычно говорит браузеру, что он не должен выполнять действий по умолчанию.

Если обработчик события onbeforeunload объекта Window вернет строку, эта строка будет выведена в модальном диалоге, предлагающем пользователю подтвердить свое желания покинуть страницу.

Данные значения учитываются, только если обработчики зарегистрированы с помощью установки свойств. Обработчики, зарегистрированные с помощью методов addEventListener() или attachEvent() вместо этого должны вызывать метод preventDefault() или устанавливать свойство returnValue объекта события.

!3 Порядок вызова

Обработчики события элемента вызываются в следующем порядке:

{:
* В первую очередь вызываются обработчики, зарегистрированные установкой свойства объекта или с помощью HTML-атрибута, если таковые имеются.
*  Затем вызываются обработчики, зарегистрированные с помощью метода addEventListener(), в порядке их регистрации.
* Обработчики, зарегистрированные с помощью метода attachEvent(), могут вызываться в произвольном порядке, поэтому ваши сценарии не должны полагаться на какой-то определенный порядок.
:}

!3 Распространение событий

{!
Перехват -- Работает во всех браузерах кроме IE<8. В данной фазе участвуют только обработчики, зарегистрированные с помощью метода addEventListener(), когда в третьем аргументе ему передано true. В первую очередь вызываютя перехватывающие обработчики объекта Window, затем вызываются перехватывающие обработчики объекта Document, затем обработчики объекта body и т.д., вниз по дереву DOM, пока не будут вызваны перехватывающие обработчики родителя цедевого элемента. Перехватывающие обработчики, зарегистрированные в самом целевом элементе, !!не !!вызываются. 
Целевой элемент -- Вызываются обработчики целевого элемента.
Всплытие -- Способностью всплывать обладает большинство событий, возникающих в элементах документа. Заметным исключением являются события !!focus, !!blur, !!scroll. Событие !!load, возникающее в элементах, также всплывает, но оно прекращает всплывать в объекте Document и не достигает объекта Window.
!}

!3 Отмена событий

Если обработчик регистрируется как свойство, можно использовать возвращаемое значение для отмены действий, выполняемых по умолчанию. В обработчике, регистрируемом с помощью метода addEventListener(), отменить выполнение действий по умолчанию можно также вызовом метода event.preventDefault(). Однако в IE<8 тот же эффект достигается установкой свойства returnValue объекта события в значение false.

{-
event.preventDefault(); // Стандартный прием.
event.returnValue = false; // IE<8
return false; // Для обработчиков-свойств.
-}

Текущий проект модуля "DOM Events" определяет в объекте Event свойство с именем !!defaultPrevented. Оно пока поддерживается не всеми браузерами, но суть его в том, что при обычных условиях оно имеет значение false и принимает значение true только в случае вызова метода preventDefault().

Остановка распространения события:

{-
event.stopPropagation(); // Стандартный прием. Обработчики, зарегистрированные в том же элементе, будут вызваны. Действует во всех трех фазах распространения события.
event.cancelBubble = true; // IE<8. Действует только в фазе всплытия.
-}

Текущий проект спецификации "DOM Events" определяет в объекте Event еще один метод - !!stopImmediatePropagation(). Он не только предотвращает распространение события по любым другим объектам, но также предотвращает вызов любых других обработчиков, зарегистрированных в том же объекте.