!1 Объект Document

!2 Обзор модели DOM

Объектная модель документа (DOM) — это фундаментальный прикладной интерфейс, обеспечивающий возможность работы с содержимым HTML и XML документов.

Узел, расположеный непосредственно над данным узлом, называется !!родительским по отношению к данному узлу. Узлы, расположенные на один уровень ниже другого узла, являются !!дочерними по отношению к данному узлу. Узлы, находящиеся на одном и том же уровне и имеющие того же родителя называются !!братьями. Узлы, расположенные на любое число уровней ниже другого узла, являются его !!потомками. Родительские, прародительские и любые другие узлы, расположенные выше данного узла, являются его !!предками.

Каждый элемент является узлом документа, который представлен объектом !!Node. Корнем дерева является объект !!Document, представляющий документ целиком. Узлы, представляющие HTML-элементы, являются узлами типа !!Element, а узлыы, представляющие текст — узлами типа Text. Document, Element и Text - это подклассы класса Node.

Объект !!Document является обобщенным типом для HTML- (!!HTMLDocument) и XML-документов.


{:
* Node
{:
* Document
{:
* HTMLDocument
:}
* CharacterData
{:
* Text
* Comment
:}
* Element
{:
* HTMLElement
* HTMLHeadElement
* HTMLBodyElement
* HTMLTitleElement
* HTMLParagraphElement
* HTMLInputElement
* HTMLTableElement
* и т.д.
:}
* Attr
:}
:}

!2 Выбор элементов документа

:}
* По значению атрибута !!id.
* По значению атрибута !!name;
* По имени !!тега.
* По имени !!класса или классов CSS.
* По совпадению с определенным !!селектором CSS.
:}

!3 Выбор элементов по значению атрибута id

{-
document.getElementById('myid');
-}

В версиях IE ниже 8 метод getElementById() выполняет поиск значений атрибутов id без учета регистра символов, и, кроме того, возвращает элементы, в которых будет найдено совпадение со значением атрибута name.

!3 Выбор элементов по значению атрибута name

{-
document.getElementsByName('myname');
-}

Данный метод определяется классом HTMLDocument, поэтому доступен только в HTML-документах. Он возвращает объект !!NodeList, который ведет себя как доступный только для чтения массив объектов Element. В IE данный метод также возвращает элементы, значения атрибутов id которых совпадает с указанным значением.

Наличие атрибута name в элементе <form>, <img>, <iframe>, <applet>, <embed> или <object> (но только в элементе <object>, который не имеет вложенных объектов с альтернативным содержимым) приводит к созданию  свойства в объекте Document, имя которого совпадает со значением атрибута (при этом предполагается, что объект документа еще не имеет свойства с этим именем).

Если существует только один элемент с указанным именем, значением автоматически созданного свойства документа станет сам элемент. Если таких элементов несколько, значением свойства будет объект NodeList, играющий роль массива элементов.

!3 Выбор элементов по тегу

{-
document.getElementsByTagName('span'); // Позволяет выбрать все HTML или XML элементы указанного типа (или по имени тега).
-}

Данный метод возвращает объект NodeList. Элементы документа включаются в массив NodeList в том же порядке, в каком они следуют в документе.

Данный метод выполняет сравнение с именем тега без учета регистра символов.

Если передать данному методу шаблонный символ "*", он вернет NodeList, содержащий все элементы документа.

{!Кроме того, класс !!Element также определяет метод !!getElementsByTagName(). Он действует точно так же, но выбирает только элементы, являющиеся потомками для элемента, относительно которого вызывается метод.!}

Класс !!HTMLDocument определяет специальные свойства для доступа к узлам определенных типов. Например, свойства !!images, !!forms и !!links ссылаются на объекты, подобные массивам, доступные только для чтения, содержащие элементы <img>, <form> и <a> (но только те теги <a>, которые имеют атрибут href). Эти свойства ссылаются на объекты HTMLCollection, которые во многом  похожи на объекты NodeList, но дополнительно могут индексироваться значениями атрибутов id и name.

{-
document.forms.shipping_address;
-}

Объект HTMLDocument также определяет свойства-синонимы !!embeds и !!plugins, являющиеся коллекциями HTMLCollection элементов <embed>. Свойство !!anchors является нестандартным, но с его помощью можно получить доступ к элементам <a>, имеющим атрибут name, но не имеющим атрибут href. Свойство !!scripts определено стандартом HTML5 и является коллекцией HTMLCollection элементов <script>, но к моменту написания этих строк оно было реализовано не во всех браузерах.

Кроме того, объект HTMLDocument определяет два свойства, каждое из которых ссылается не на коллекцию, а на единственный элемент. Свойство document.!!body представляет элемент <body>, а свойство document.!!head - элемент <head>. Эти свойства всегда определены в документе, даже если в разметке отсутствуют соответствующие элементы. Свойство document.!!documentElement ссылается на корневой элемент документа (в HTML - <html>).

!3 Объекты NodeList и HTMLCollection

Эти объекты являются объектами, подобными массивам, доступным только для чтения. Они имеют свойство length и могут индексироваться подобно настоящим массивам.

Для этих объектов нельзя непосредственно вызвать методы класса Array, но их можно вызвать косвенно.

Объекты HTMLCollection могут иметь дополнительные именованные свойства и могут индексироваться не только числами, но и строками.

По историческим причинам, оба объекта, NodeList и HTMLCollection, могут также играть роль функций: вызов их с числовым или строковым аргументом равносилен операции индексирования числом или строков.

Оба объекта проектировались под менее динамические языки, поэтому они имеют методы item() - принимает целочисленное значение и возвращает элемент, и namedItem() - возвращает значение именованного свойства.

}!Данные объекты являются динамическими, т.е. изменяются вместе с документом.!}

!3 Выбор элементов по классу CSS

Слово class является зарезервированным, поэтому для хранения атрибута class в клиентском JavaScript используется свойство !!className. HTML5 определяет метод !!getElementsByClassName(), позволяющий выбирать множества элементов документа на основе идентификаторов в их атрибутах class.

{-
document.getElementsByClassName('fatal error');
-}

Данный метод может вызываться как для HTMLDocument, так и для HTMLElement и возвращает "живой" объект NodeList, содержащий все потомки документа или элементы, соответствующие критерию поиска. Принимает единственный строковой аргумент, но в самой строке может быть указано несколько идентификаторов, разделенных пробелами.

Если документ отображается в режиме совместимости, идентификаторы классов в атрибуте class и CSS нечуствительны к регистру символов. В режиме совместимости данный метод также сравнивает строки без учета регистра.

!3 Выбор элементов с использованием селекторов CSS

Метод querySelectorAll() объекта Document принимает единственный строковой аргумент с селектором CSS и вовзращает объект NodeList, представляющий все элементы документа, соответствующие селектору. Данный объект NodeList !!не !!является "живым". В случае отсутствия элементов с указанным селектором, метод вернет пустой объект NodeList.

Метод querySelector() объекта Document аналогичен querySelectorAll() за исключением того, что он возвращает только первый из найденных элементов или null в случае отсутствия найденных элементов.

{-
document.querySelectorAll(selector);
document.querySelector(selector);
-}

Эти два метода также определяются классом Elements (и классом DocumentFragment). Когда они вызываются относительно элемента, поиск соответствия заданному селектору выполняется во всем документе, а затем результат фильтруется так, чтобы в нем остались только потомки использованного элемента.

Псевдоселекторы :first-line, :first-letter, :link, :visited не будут обнаруживать совпадений.

!3 document.all[]

В IE4 была реализована коллекция document.all[], представляющая все элементы. Теперь она считается устаревшей и не должна использоваться.

{-
document.all[0];
document.all['myid'];
-}

!2 Структура документа и навигация по документу

!3 Документы как деревья узлов

Класс Node определяет следующие важные свойства:

:}
* !!parentNode: Родительский узел данного узла или null для узлов, не имеющих родителя, таких как Document.
* !!childNodes: Доступный для чтения объект, подобный массиву (NodeList), обеспечивающий "живое" представление дочерних узлов.
* !!firstChild, !!lastChild: Первый и последний дочерние узлы или null, если данный узел не имеет дочерних узлов.
* !!nextSubling, !!previousSubling: Следующий и предыдущий братские узлы.
* !!nodeType: Тип данного узла. Узлы типа Document имеют значение 9 в этом свойстве. Узлы типа Element - значение 1. Текстовые узлы типа Text - 3, Comments - 8, DocumentFragment - 11.
* !!nodeValue: Текстовое содержимое узлов Text и Comment.
* !!nodeName: Имя тега элемента Element, в котором все символы преобразованы в верхний регистр.
:}

!3 Документы как деревья элементов

Свойство children объекта Element содержит объект NodeList, который включает все дочерние элементы (в отличие от childNodes только элементы, без Text и Comment).

Объект Element содержит дополнительные свойства для доступа к дереву элементов:

:}
* !!firstElementChild, !!lastElementChild: Похожи на свойства firstChild и lastChild, но возвращают дочерние элементы.
* !!nextElementSubling, !!previousElementSubling: Похожи на свойства nextSubling и previousSubling, но возвращают братские элементы.
* !!childElementCount: Количество дочерних элементов. Возвращает то же значение, что и свойство children.length.
:}

Данные свойства реализованы во всех браузерах, !!кроме !!IE.

!2 Атрибуты

!3 HTML-атрибуты как свойства объектов Element

Объекты HTMLElement определяют свойства, доступные для чтения}записи, соответствующие HTML-атрибутам элементов. 

{-
image.src; // Получение адреса изображения.

// Установка атрибутов формы
form.action = '}register}';
form.method = 'POST';
-}

Если имя атрибута является зарезервированным словом, оно начинается с приставки html (htmlFor). Исключением из этого правила является атрибут class - ему соответствует свойство className.

Свойства, представляющие атрибуты, обычно имеют строковые значения. Если атрибут имеет логическое или числовое значение, значением соответствующего свойства будет логическое или числовое значение, а не строка. Значениями атрибутов обработчиков событий всегда являются объекты Function (или null). Значением свойства style любого HTML-элемента является объект CSSStyleDeclaration, а не строка.

Данный интерфейс не позволяет удалять атрибуты, нельзя использовать оператор delete.

!3 Доступ к нестандартным HTML-атрибутам

{-
elem.setAttribute('class', 'myclass');
elem.getAttribute('class');
-}

Данные методы интерпретируют значения всех атрибутов как строки. Они также принимают стандартные имена атрибутов, даже если они совпадают с зарезервированными словами. Имена атрибутов HTML-элементов нечувствительны к регистру.

{-
elem.hasAttribute('attr');
elem.removeAttribute('attr');
-}

Для работы с XML-документами, содержащими атрибуты из других пространств имен, существуют методы, позволяющие указывать пространство имен:

{-
setAttributeNS();
getAttributeNS();
hasAttributeNS();
removeAttributeNS();
-}

!3 Атрибуты с данными

Стандарт HTML5 предусматривает возможность назначения нестандартных атрибутов, имена которых начинаются с приставки "data-". Такие атрибуты (в отличие от произвольных имен нестандартных атрибутов) не нарушают стандарт.

Кроме того, HTML5 определяет в объекте Element свойство dataset. Это свойство ссылается на объект, который имеет свойства, имена которых соответствуют именам атрибутов data- без приставки. Имена атрибутов с дефисами отображаются в имена свойств с переменным регистром символов (data-jquery-test -> dataset.jqueryTest). Данное свойство является "живым" двунаправленным интерфейсом к атрибутам.

!3 Атрибуты как узлы типа Attr

Тип Node определяет свойство attributes. Это свойство имеет значение null для всех узлов, не являющихся объектами Element. Данное свойство является объектом, подобным массиву, доступным только для чтения, представляющим все атрибуты элемента. Является динамическим объектом. Может индексироваться числами и именами атрибутов.

{-
document.body.attributes[0];
document.body.attributes.bgcolor;
document.body.attributes['ONLOAD'];
-}

Значениями, получаемыми в результате индексирования объекта attributes, являются объекты Attr. Это специализированный подтип Node, который имеет свойства name и value.

!2 Содержимое элемента

!3 Содержимое элемента в виде HTML

{-
element.innerHTML; // Содержимое элемента в виде строки разметки.
-}

Попытка изменить значение этого свойства приводит к вызову синтаксического анализатора браузера и замещению текущего содержимого элемента разобранным представлением новой строки. Несмотря на свое название, может использоваться и для работы с XML содержимым.

Это свойство было стандартизировано только с появлением HTML5. Спецификация требует, чтобы данное свойство было реализовано не только в объекте Element, но и в объекте Document, однако это требование реализуют пока не все браузеры.

Кроме того, спецификация HTML5 определяет свойство с именем !!outerHTML. Оно содержит весь тег элемента целиком, с открывающим и закрывающим тегами. При записи значения в данное свойство новое содержимое заменяет элемент целиком.

HTML5 определяет метод insertAdjacentHTML(), дающий возможность вставить строку с разметкой, прилегающую к указанному элементу.

{-
elem.insertAdjacentHTML('beforebegin', html); // Перед открывающим тегом.
elem.insertAdjacentHTML('afterbegin', html); // После открывающего тега.
elem.insertAdjacentHTML('beforeend', html); // Перед закрывающим тегом.
elem.insertAdjacentHTML('afterend', html); // После закрывающего тега.
-}

Данный метод !!не !!поддерживается многими браузерами.

!3 Содержимое элемента в виде простого текста

{-
element.textContent; // Поддерживается всеми текущими браузерами кроме IE. Возвращает результат простой конкатенации всех узлов Text, потомков указанного элемента.
element.innerText; // Поддерживается всеми текущими браузерами кроме Firefox. Данное свойство не возвращает содержимое элемента <script>, из возвращаемого им текста удаляются лишние пробелы и предпринимается попытка сохранить табличное форматирование. Для некоторых элементов таблиц, таких как <table>, <tbody> и <tr> данное свойство доступно только для чтения.
-}

Элементы <script> имеют свойство text, которое можно использовать для получения их содержимого в виде текста.

!2 Создание, вставка и удаление узлов

{-
var newnode = document.createElement('<tag>'); // Создание нового элемента.
var newnode = document.createTextNode('Содержимое'); // Создание текстового узла.

// Также существуют и другие фабричные методы для создания узлов:
document.createComment();
document.createDocumentFragment();
document.createElementNS();
-}

Другой метод создания узлов состоит в копировании существующих узлов. Каждый узел имеет метод !!clodeNode(), возвращающий новую копию узла. Если передать ему аргумент true, он рекурсивно создаст копии всех потомков, в противном случае будет создана лишь поверхностная копия.

В браузерах, отличных от IE, также существует похожий метод document.importNode(). Если передать ему узел из другого документа, он вернет копию, пригодную для вставки в текущий документ. Если передать ему true во втором аргументе, он рекурсивно импортирует все узлы-потомки.

!3 Вставка узлов

{-
parent.appendChild(node); // Вставляет узел так, что тот становится последним дочерним узлом.
parent.insertBefore(elem, beforeElem); // Вставляет узел в родительский перед указанным.
-}

Если данные методы используются для вставки узла, который уже находится в составе документа, этот узел будет автоматически удален ил текущей позиции и вставлен в новую позицию.

!3 Удаление и замена узлов

{-
parent.removeChild(child); // Удаление узла.
parent.replaceChild(to, from); // Удаляет дочерний узел и заменяет его другим.
-}

!3 Использование объектов DocumentFragment

DocumentFragment - это особая разновидность объектов Node. Они служат временным контейнером для других узлов.

{-
var frag = document.createDocumentFragment(); // Создание объекта DocumentFragment.
-}

Данные объекты являются самостоятельными и не входят в состав какого-либо другого документа. Его свойство parentNode всегда возвращает null. Данные объекты могут иметь любое количество дочерних элементов, которыми можно управлять.

Если передать фрагмент методу appendChild() или другим методам вставки, в документ будут вставлены дочерние элементы фрагмента, а не сам фрагмент (дочерние элементы будут перемещены из фрагмента в документ, а сам фрагмент опустеет и будет готов для повторного использования).

!2 Геометрия документа и элементов и прокрутка

!3 Координаты документа и видимой области

Определение положения полос прокрутки:

{-
// Во всех браузерах, кроме IE версии 8 и ниже:
window.pageXOffset;
window.pageYOffset;

// В IE и всех современных браузерах (стандартный режим):
document.documentElement.scrollLeft;
document.documentElement.scrollTop;

// В IE и всех современных браузерах (режим совместимости):
document.body.scrollLeft;
document.body.scrollTop;
-}

Определение размера видимой области:

{-
// Во всех браузерах кроме IE версии ниже 8:
window.innerWidth;
window.innerHeight;

// В IE и всех современных браузерах (стандартный режим):
document.documentElement.clientWidth;
document.documentElement.clientHeight;

// В IE и всех современных браузерах (режим совместимости):
document.body.clientWidth;
document.body.clientHeight;
-}

!3 Определение геометрии элемента

Метод getBoundingClientRect() не принимает аргументов и возвращает объект со свойствами left, right, top и bottom.

{-
elem.getBoundingClientRect();
-}

Данный метод возвращает позицию элемента в системе координат видимой области.

Во многих браузерах (и в стандарте W3C) объект, возвращаемый данным методом, имеет свойства width и height, но оригинальная реализация в IE не поддерживает их.

Координаты, возвращаемые методом getBoundingClientRect(), включают рамку и отступы элемента, но не включают поля.

Объект, возвращаемый данным методом, не является динамическим, то есть хранит статические сведения о визуальном представлении документа.

!3 Определение элемента в указанной точке

{-
document.elementFromPoint(x, y); // Принимает координаты !!видимой !!области и возвращает объект Element, находящийся в этой позиции.
-}

Данный метод должен возвращать самый внутрениий и самый верхний элемент, находящийся в этой точке. Если передать ему координаты точки, находящейся за пределами видимой области, метод вернет null, даже если после пробразования в систему координат документа получится вполне допустимая точка.

!3 Прокрутка

Для прокрутки можно присвоить значение свойствам scrollLeft и scrollTop, но существует более простой способ. Метод !!scrollTo() объекта Window (и его синоним !!scroll()) принимает координаты x и y точки (относительно начала координат документа) и устанавливает их в качестве величин смещения полос прокрутки. То есть, он прокручивает окно так, что точка с указанными координатами оказывается в верхнем левом углу видимой области.

{-
window.scrollTo(x, y); // Абсолютное смещение.
window.scrollBy(x, y); // Относительное смещение (значения добавляются к текущим смещениям).
-}

{-
element.scrollIntoView(); // Гарантирует, что элемент окажется в видимой области. По умолчанию старается прокрутить документ так, чтобы верхняя граница элемента оказалась как можно ближе к верхней границе видимой области. Если в аргументе передать false, он попытается прокрутить документ так, чтобы нижняя граница элемента совпала с нижней границей видимой области.
-}

!3 Подробнее о размерах, позициях и переполнении элементов

Метод getBoundingClientRect() поддерживается всеми текущими браузерами, однако для поддержки старых браузеров необходимо пользоваться другими способами получения геометрии элемента.

Каждый элемент имеет следующие свойства:

{-
// Размер элемента (доступно только для чтения). Включают рамку элемента и отступы, но не включают поля.
offsetWidth
offsetHeight

// Координаты X и Y. Для потомков позиционируемых элементов, таких как ячейки таблиц, эти свойства возвращают координаты относительно элемента-предка.
offsetLeft
offsetTop

offsetParent // Определяет элемент, относительно которого отсчитываются координаты. Если координаты отсчитываются относительно начала документа, имеет значение null.
-}

{-
// Включают только область содержимого и отступы, не включают рамку. Если браузер добавляет между рамкой и отступами полосы прокрутки, данные свойства не включают ширину полос прокрутки. Для строчных элементов всегда возвращают 0.
clientWidth
clientHeight

// Возвращают расстояние по горизонтали и вертикали между внешней границей отступов элемента и внешней границей его рамки. Обычно эти значения просто определяют ширину левой и верхней рамки. Однако, если элемент имеет полосы прокрутки и если браузер помещает эти полосы прокрутки вдоль левого или верхнего края, значения данных свойств также будут включать ширину полос прокрутки. Для строчных элементов всегда возвращают 0.
clientLeft
clientTop
-}

{-
// Определяют размер области содержимого элемента, плюс его отступы, плюс ширину и высоту области содержимого, выходящую за видимую область. Когда содержимое целиком умещается в видимой области, значения этих свойств совпадают со значениями свойств clientWidth и clientHeight.
scrollWidth
scrollHeight

// Определяют позиции полос прокрутки элемента. Данные свойства доступны для записи и им можно присваивать значения, чтобы прокрутить содержимое элемента.
scrollLeft
scrollTop
-}

!3 HTML-формы

!3 Выбор форм и элементов форм

Объекты Form сами по себе действуют подобно объектам HTMLCollection, хранящим элементы форм, и могут индексироваться именами или числами.

{-
// <form name="address">
// <input name="street">
document.forms.address[0];
document.forms.address.street;
document.address.street;
-}

Если необходимо явно указать, что выполняется обращение к элементу формы, вместо объекта формы можно индексировать его свойство elements:

{-
document.forms.address.elements[0];
document.forms.address.elements.street;
-}

Когда объект HTMLCollection индексируется именем и существует несколько элементов, использующих одно и то же имя, возвращаемым значением является объект, подобный массиву, содержащий все элементы с указанным именем.

!3 Свойства форм и их элементов

{-
// Данные свойства доступны для чтения и записи.
form.action;
form.encoding;
form.mathod;
form.target;
-}

{-
form.submit(); // Производит отправку формы.
form.reset(); // Сбрасывает форму в начальное состояние.
-}

У всех (или у большинства) элементов форм есть общие свойства:

{-
elem.type; // Доступная только для чтения строка, идентифицирующая тип элемента формы.
elem.form; // Доступная только для чтения ссылка на объект Form, в котором содержитыя этот элемент или null, если элемент не находится внутри элемента <form>.
elem.name; // Доступная только для чтения строка, указанная в атрибуте name.
elem.value; // Доступная для чтения и записи строка, определяющая значение, содержащееся в элементе формы или представляемое им.
-}

!3 Обработчики событий форм и их элементов

Обработчик !!onsubmit вызывается непосредственно перед отправкой формы. Он может отменить отправку, вернув значение false. Данный обработчик вызывается только в случае щелчка на кнопке Submit. Вызов метода submit() формы не приводит к вызову обработчика onsubmit.

Обработчик onreset вызывается непосредственно перед сбросом формы в исходное состояние и может предотвратить сброс, вернув false. Данный обработчик также вызывается только в случае щелчка на кнопке Reset.

Элементы возбуждают события !!click, !!change, !!focus, !!blur.

!3 Переключатели и флажки

И флажки, и переключатели, имеют свойство !!checked. Это доступное для чтения и записи логическое значение определяет, отмечен ли элемент в данный момент. Свойство !!defaultChecked представляет собой доступное только для чтения логическое значение, содержащее значение атрибута checked.

!3 Элементы Select и Option

Если в теге определен атрибут multiple, пользователь сможет выбрать несколько вариантов, а свойство type объекта Select будет иметь значение "select-multiple". В противном случае, если атрибут miltiple отсутствует, свойство type будет иметь значение "select-one".

Элемент Select определяет свойство !!options, которе является объектом, подобным массиву, хранящим объекты Option.

Для элементов Select с возможностью выбора единственного варианта, доступное только для чтения свойство !!selectedIndex определяет выбранный в данный момент вариант. Если разрешено выбирать несколько вариантов, для определения выбранных следует в цикле перебрать элементы массива !!options[] и проверить значения свойства selected каждого объекта Option.

Кроме свойства !!selected у каждого объекта Option есть свойство !!text, задающее строку текста, которая отображается в элементе Select для данного варианта. Свойство !!value представляет доступную для чтения и записи строку, которая отсылается на сервер при передаче данных формы.

Можно обрезать массив элементов Option, установив свойство options.length равным требуемому количеству вариантов, или удалить все объекты Option, установив значение свойства options.length равным нулю. Можно удалять отдельные объекты Option из элемента Select, присваивая элементам массива options[] значение null. В этом случае удаляются соответствующие объекты Option, а все элементы, расположенные в массиве options[] правее, автоматически сдвигаются влево.

Чтобы добавить в элемент Select новый вариант, можно создать его с помощью конктруктора Option() и добавить в конец массива options[]:

{-
var zaire = new Option('Zaire' // Свойство test
					   'zaire', // Свойство value
					   false, // Свойство defaultSelected
					   false); // Свойство selected
myselect.options[myselect.options.length] = zaire;
-}

!2 Другие особенности документов

!3 Свойства объекта Document

Кроме указанных, объект Document содержит еще несколько свойств, которые могут представлять интерес:

{-
cookie // Специальное свойство, позволяющее JavaScript-программам читать и писать cookie-файлы.
domain // Свойство, которое позволяет доверяющим друг другу веб-серверма, принадлежащим одному домену, ослаблять ограничения, накладываемые политикой общего происхождения.
lastModified // Строка, содержащая дату последнего изменения документа.
location // Это свойство ссылается на тот же объект Location, что и свойство location объекта Window.
referrer // URL-адрес документа, содержащего ссылку (если таковая существует), которая привела браузер к текущему документу. Это свойство имеет то же значение, что и HTTP-заголовок Referer, но записывается с двумя буквами r.
title // Текст тега <title>.
URL // Строка, доступная только для чтения. Совпадает с начальным значением свойства location.href, но в отличие от объекта Location, не является динамическим.
-}

!3 Метод document.write()

Данный метод объединяет свои строковые аргументы и вставляет получившуюся строку в документ, в точку вызова метода.

Содержимое, переданное методу write(), может буферизоваться, пока не будет выполнен завершающий вызов метода !!close().

Объект document поддерживает также метод writeln(), который идентичен методу write(), за исключением того, что он добавляет символ перевода строки после вывода своих аргументов.

!3 Получение выделенного текста

{-
// HTML5
window.getSelection().toString(); // Возвращает объект Selection, описывающий текущий выделенный текст как последовательность одного или более объектов Range. Его метод toString() возвращает выделенный текст.
// IE
document.selection.createRange().text;
-}

Получение выделенного текста в поле ввода или элементе <textarea>:

{-
// Данные свойства не поддерживаются в версиях IE8 и ниже.
elem.value.substring(elem.selectionStart, elem.selectionEnd);
-}

!3 Редактируемое содержимое

{-
// Включение редактируемого содержимого.
<div id="editor" contenteditable>
	Щелкните, чтобы отредактировать.
<}div>
-}

{-
// Включение редактирования всего документа.
document.designMode = 'on';
// Отключение редактирования всего документа.
document.designMode = 'off';
-}

Все текущие браузеры поддерживают свойства contenteditable и designMode. Однако они могут быть плохо совместимыми, так как разные браузеры генерируют разную разметку.

Можно выполнять команды, связанные с текущим редактируемым элементом:

{-
// Выполнить команду:
document.execCommand('bold');
// Поддерживается ли команда браузером:
document.queryCommandSupported('bold');
// Доступна ли команда в настоящее время:
document.queryCommandEnabled('bold');
// Определение текущего состояния команды:
document.queryCommandState('bold');
// Получить текущее значение команды:
document.queryCommandValue('fontname');
-}