// Создание своего класса потока
class MyThread extends Thread {
    public void run() {
        //...
    }
}
Thread tread = new MyThread();
thread.getName(); // Получить имя потока
thread.getPriority(); // Получить приоритет потока
thread.isAlive(); // Определить, выполняется ли еще поток
thread.join(); // Ждать завершения потока
thread.run(); // Указать точку входа в поток
thread.sleep(1000); // Приостановить поток на определенный период времени (в миллисекундах)
thread.start(); // Старт выполнения

Thread.currentThread(); // Получение текущего потока

public void myMethod() throws InterruptedException {} // Каждый метод, выполняющий операции с потоками может порождать данное исключение

/* Приоритеты потоков */

thread.setPriority(5); // Установка приоритета потока (от MIN_PRIORITY до MAX_PRIORITY)
thread.getPriority(); // Возвращает приоритет потока

/* Синхронизация */

// Синхронизированный метод (все другие потоки с данным экземпляром будут ожидать освобождения вызова этого метода)
public synchronized void myMethod() {}

// Использование оператора синхронизации
synchronized(object) {
    // ...
}

/* Межпоточные связи */

object.wait(); // Сообщает вызывающему потоку, что нужно освободить объект и ждать пока другой поток не вызовет метод notify()
object.notify(); // Продолжить выполнение первого, вызвавшему wait() для данного объекта
object.notifyAll(); // Продолжить выполнение всех потоков, вызвавших метод wait() для данного объекта

// Для приостановки и возобновления потока необходимо использовать собственный флаг, который периодически проверяется в методе run(), и в зависимости от него останавливает или возобновляет работу