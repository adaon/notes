// ----------------------------------- Управление потоками

stream.flush(); // Сбрасывает на диск содержимое потока

stream.seekg(int index, ios::begin|ios::cur|ios::end); // Перемещает указатель, отвечающий ща ввод
stream.seekp(int index, ios::begin|ios::cur|ios::end); // Перемещает указатель, отвечающий ща вывод

int g = stream.tellg(); // Возвращает текущую позицию указателя ввода
int p = stream.tellp(); // Возвращает текущую позицию указателя вывода

stream.rdbuf(); // Возвращает указатель на буфер потока streambuf
out << in.rdbuf(); // Вывод указателя буфера в поток выводит все данные,содержащиеся в потоке

istream.gcount(); // Возвращает количество символов, считанных при выполнении последней операции ввода
istream.ignore(num, delim); // Считывает и игнорирует количество символов num-1 или до delim
istream.readsome(buffer, num); // Считывает num символов (или меньше) из потока в буфер

// ----------------------------------- Работа с файлами

#include <fstream>;
ifstream in("filename"); // Открытие файлового потока ввода
ofstream out("filename"); // Открытие файлового потока вывода
fstream str("filename", ios::in|out|app|ate|trunc|binary);
ifstream in("filename", ios::binary); // Открытие бинарного файлового потока ввода
ofstream out("filename", ios::binary); // Открытие бинарного файлового потока вывода

assure(stream, "filename"); // Проверяет, был ли файловый поток успешно открыт

fstream.open("filename"); // Связывает имя файла с потоком

// ----------------------------------- Работа с бинарными данными

stream.write(char* buffer, size); // Помещает байты в файл
stream.read(char* buffer, size); // Считывает байты из файла в переменную buffer

// ----------------------------------- Работа с символьными потоками

#include <string>;
getline(stream, str); // Записывает строку из потока stream в строку str;

stream.put(byte); // Помещает байт в файл
stream.get(char c); // Считывает байт из файла в переменную
stream.get(char* buffer, size); // Считывает байты в массив
stream.get(char* buffer, size, delim); // Считывает байты в массив до конца размера или достижения delim-символа
int i = stream.get(); // Возвращает следующий байт. При достижении конца файла возвращает EOF

stream.getline(buffer, size);
stream.getline(buffer, size, delim);

int i = stream.peek(); // Считывает следующий символ, не удаляя его из потока
stream.putback(char c); // Возвращает в поток считанный символ

istringstream is("string"); // Создание строкового потока с инициализацией
ostringstream os;

// ----------------------------------- Проверка ошибок

iostate is = stream.rdstate(); // Возвращает ios::goodbit при отсутствии ошибок последней операции.
stream.setstate(ios::failbit); // Установка статуса потока
// ios::eofbit // 1 при конце файла, 0 в противном случае
// ios::failbit // 1 при исправимой ошибке ввода-вывода
// ios::badbit // 1 при неисправимой ошибке ввода-вывода

stream.bad(); // true-false
stream.eof(); // true-false
stream.fail(); // true-false
stream.good(); // true-false

stream.clear(); // Очищает флаги ошибок

if(stream >> x) {/*...*/} // Использование потока в логическом выражении возвращает true или false

stream.exceptions(ios::badbit | ios::failbit); // Разрешение вызова исключения std::ios:failure при ошибке потока 
// В частности, для проверки отсутствия файла используется флаг ios::failbit

// ---------------------------------- Форматирование

stream.setf(ios::flag); // Установка влага форматирования:
stream.unsetf(ios::flag);
/*
skipws    = 0x0001, // отбрасывание пробелов
left      = 0x0002, // выравнивание по левому краю
right     = 0x0004, // выравнивание по правому краю
internal  = 0x0008, // заполнение пустых позиций
dec   = 0x0010,     // выдача в десятеричном формате
oct   = 0x0020,     // выдача в восьмеричном формате
hex   = 0x0040,     // выдача в шестнадцетиричном формате
showbase  = 0x0080, // выдача основания системы счичления
showpoint = 0x0100, // выдача позиции точки
uppercase = 0x0200, // выдача в формате xx.xxxx Exx
showpos   = 0x0400, // выдача знака у положительного числа
scientific= 0x0800, // выдача в форме с фиксированной точкой
fixed     = 0x1000, // выдача в форме с плавающей точкой
unitbuf   = 0x2000, // улучшенная выдача
stdio     = 0x4000  // щсвобождение потока
*/

cout.width(/*20*/); // Возвращает текущую ширину поля. Устанавливает ширину поля.
cout.fill(/*'#'*/); // Возвращает текущий символ заполнения. Устанавливает символ-заполнитель
cout.precision(/*50*/); // Возвращает текущее количество символов после точки (вместе с точкой).
// Устанавливает кол-во символов после точки

// Манипуляторы ввода-вывода:
// При использовании манипуляторов, принимающих параметры,
// необходимо включить заголовок <iomanip>
/*
boolalpha				Устанавливает флаг boolalpha	Ввод-вывод
dec						Устанавливает флаг dec			Ввод-вывод
endl													Вывод
ends					Вставляет нулевой символ		Вывод
fixed					//-//-//						Вывод
flush					Сбрасывает поток				Вывод
hex						//-//-//						Ввод-вывод
internal				//-//-//						Вывод
left					//-//-//						Вывод
noboolalpha				//-//-//						Ввод-вывод
noshowbase				//-//-//						Вывод
noshowpoint				//-//-//						Вывод
noshowpos				//-//-//						Вывод
noskipws				//-//-//						Ввод
nounitbuf				//-//-//						Вывод
nouppercase				//-//-//						Вывод
oct						//-//-//						Ввод-вывод
resetiosflags(fmtflags f)								Ввод-вывод
right					//-//-//						Вывод
scientific				//-//-//						Вывод
setbase(int base)		Устанавливаени систему сч.		Вывод
setfill(int ch)											Вывод
setiosflags(fmtflags f)									Ввод-вывод
setprecision(int p)										Вывод
setw(int w)				Устанавливает ширину поля		Вывод
showbase				//-//-//						Вывод
showpoint				//-//-//						Вывод
showpos					//-//-//						Вывод
skipws					//-//-//						Ввод
unitbuf					//-//-//						Вывод
uppercase				//-//-//						Вывод
ws						Пропускает ведущие проб. симв.	Ввод
*/

// Создание собственной манипуляторной функции, не принимающей аргументы
ostream& manip_name(ostream &stream) {
	/*...*/
	return stream;
}