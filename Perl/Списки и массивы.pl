# Если индекс массива не является целым числом, то будет автоматически усечен до ближайшего меньшего целого числа
$fred[0] = "Hello";
$fred[1] = "Hello2";
# Если используется индекс, выходящий за границы массива, будет возвращено значение undef
# Если при присваивании используется индекс, выходящий за границы массива, массив автоматически расширяется до n элементов, каждый из которых содержим undef
$#arr # Получение индекса последнего элемента массива
$fred[-1] # Допустимыми являются и отрицательные индексы

$fred = (1, 2, 3, 4); # Литерал массива
$fred = (1..100); # Диапазонный оператор .. Создает диапазон с шагом 1
("word1", "word2", "word3", "word4"); # Массив строковых литералов
qw( word1 word2 word3 word4 ); # Массив строковых литералов (альтернативная запись). Вместо () могут использоваться ЛЮБЫЕ знаки препинания
($f1, $f2, $f3) = (1, 2, 3); # Групповое присваивание
($rocks[0], $rocks[1]) = qw( str1, str2 ); # Пример построение строкового массива

@arr; # Обращение ко всему массиву сразу
@arr1 = (@arr2, "hello"); # При подобном присваивании в массив arr1 включаются все элементы массива arr2
@arr1 = @arr2; # Копирование списка из одного массива в другой

pop(@arr); # Удаляет из массива последний элемент и возвращает его
push(@arr, 5); # Добавляет элемент в конец массива
shift(@arr); # Удаляет элемент из начала массива и возвращает его
unshift(@arr, 5); # Добавляет элемент в начало массива
reverse(@arr); # Переставляет элементы массива в обратном порядке и возвращает его
sort(@arr); # Сортирует массив и возвращает его
chomp(@arr); # Удалить все завершающие символы новой строки

print "dgs @arr dgs"; # Массивы также автоматически интерполируются в строках (при этом элементы массива разделяются пробелами)

# Конструкция foreach. Если управляющая переменная не указана ($rock), автоматически используется переменная $_
foreach $rock (@arr) {
    print $rock;
}
foreach (@arr) {
    print $_;
}

### Скалярный и списочный контекст ###
# В скалярном контексте массив заменяется количеством его элементов
sort(@arr); # Сортировка массива
45 + @arr; # 45 +  кол-во элементов
@list = @people; # Список
$n = @people; # Число 3

@arr = reverse(qw(yabba dabba doo)); # Список
$str = reverse(qw(yabba dabba doo)); # oodabbadabbay (обращенный результат конкатенации всех элементов списка)

print("I have ", scalar(@rocks), " rocks!"); # Принудительное использование выражения в скалярном контексте

@arr = <STDIN>; # В случае использования потока ввода в списочном контексте в массив считываются все строки до конца файла